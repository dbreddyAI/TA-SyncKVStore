import ta_synckvstore_declare

import os
import sys
import time
import datetime

import modinput_wrapper.base_modinput
from solnlib.packages.splunklib import modularinput as smi



import input_module_kvstore_to_index as input_module


'''
    Do not edit this file!!!
    This file is generated by Add-on builder automatically.
    Add your modular input logic to file input_module_kvstore_to_index.py
'''
class ModInputkvstore_to_index(modinput_wrapper.base_modinput.BaseModInput):

    def __init__(self):
        if 'use_single_instance_mode' in dir(input_module):
            use_single_instance = input_module.use_single_instance_mode()
        else:
            use_single_instance = False
        super(ModInputkvstore_to_index, self).__init__("ta_synckvstore", "kvstore_to_index", use_single_instance)
        self.global_checkbox_fields = None

    def get_scheme(self):
        """overloaded splunklib modularinput method"""
        scheme = super(ModInputkvstore_to_index, self).get_scheme()
        scheme.title = ("KVStore to Index")
        scheme.description = ("Modular Input to pull Remote KVStore and index it locally as JSON")
        scheme.use_external_validation = True
        scheme.streaming_mode_xml = True

        scheme.add_argument(smi.Argument("name", title="Name",
                                         description="",
                                         required_on_create=True))

        """
        For customized inputs, hard code the arguments here to hide argument detail from users.
        For other input types, arguments should be get from input_module. Defining new input types could be easier.
        """
        scheme.add_argument(smi.Argument("u_splunk_server", title="Splunk Server",
                                         description="The Remote Splunk Server with the source KVStore",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("u_source_app", title="Source App",
                                         description="The remote app context with the source KVStore Collection",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("u_source_collection", title="Source Collection",
                                         description="The remote source KVStore Collection Name",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("global_account", title="Global Account",
                                         description="The stored rest API credential valid on the remote Splunk Server with permissions to the source KVStore",
                                         required_on_create=True,
                                         required_on_edit=False))
        return scheme

    def get_app_name(self):
        return "TA-SyncKVStore"

    def validate_input(self, definition):
        """validate the input stanza"""
        input_module.validate_input(self, definition)

    def collect_events(self, ew):
        """write out the events"""
        input_module.collect_events(self, ew)

    def get_account_fields(self):
        account_fields = []
        account_fields.append("global_account")
        return account_fields

    def get_checkbox_fields(self):
        checkbox_fields = []
        return checkbox_fields

    def get_global_checkbox_fields(self):
        if self.global_checkbox_fields is None:
            checkbox_fields = []
            customized_settings = {'interval': u'120', u'type': u'customized', u'parameters': [{u'default_value': u'', u'name': u'u_splunk_server', u'type': u'text', u'required': True, u'help_string': u'The Remote Splunk Server with the source KVStore', u'format_type': u'text', u'label': u'Splunk Server', u'value': u'scalpel.local', u'placeholder': u''}, {u'default_value': u'', u'name': u'u_source_app', u'type': u'text', u'required': True, u'help_string': u'The remote app context with the source KVStore Collection', u'format_type': u'text', u'label': u'Source App', u'value': u'search', u'placeholder': u''}, {u'default_value': u'', u'name': u'u_source_collection', u'type': u'text', u'required': True, u'help_string': u'The remote source KVStore Collection Name', u'format_type': u'text', u'label': u'Source Collection', u'value': u'notable_jira', u'placeholder': u''}, {u'possible_values': [], u'default_value': u'', u'name': u'global_account', u'type': u'global_account', u'required': True, u'help_string': u'The stored rest API credential valid on the remote Splunk Server with permissions to the source KVStore', u'format_type': u'global_account', u'label': u'Global Account', u'value': u'account0', u'placeholder': u''}], 'sourcetype': u'kv2idx', u'is_loaded': True, u'sample_count': u'729', 'use_external_validation': True, u'customized_options': [{u'name': u'u_splunk_server', u'value': u'scalpel.local'}, {u'name': u'u_source_app', u'value': u'search'}, {u'name': u'u_source_collection', u'value': u'notable_jira'}, {u'name': u'global_account', u'value': u'account0'}], u'disabled': True, 'index': u'default', u'name': u'kvstore_to_index', 'streaming_mode_xml': True, u'description': u'Modular Input to pull Remote KVStore and index it locally as JSON', u'data_inputs_options': [{u'default_value': u'', u'name': u'u_splunk_server', u'required_on_edit': False, u'placeholder': u'', u'format_type': u'text', u'description': u'The Remote Splunk Server with the source KVStore', u'title': u'Splunk Server', u'type': u'customized_var', u'required_on_create': True}, {u'default_value': u'', u'name': u'u_source_app', u'required_on_edit': False, u'placeholder': u'', u'format_type': u'text', u'description': u'The remote app context with the source KVStore Collection', u'title': u'Source App', u'type': u'customized_var', u'required_on_create': True}, {u'default_value': u'', u'name': u'u_source_collection', u'required_on_edit': False, u'placeholder': u'', u'format_type': u'text', u'description': u'The remote source KVStore Collection Name', u'title': u'Source Collection', u'type': u'customized_var', u'required_on_create': True}, {u'possible_values': [], u'default_value': u'', u'name': u'global_account', u'required_on_edit': False, u'placeholder': u'', u'format_type': u'global_account', u'description': u'The stored rest API credential valid on the remote Splunk Server with permissions to the source KVStore', u'title': u'Global Account', u'type': u'customized_var', u'required_on_create': True}], u'title': u'KVStore to Index', u'code': u'\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\n\n\'\'\'\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n\'\'\'\n\'\'\'\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n\'\'\'\n\ndef validate_input(helper, definition):\n    """Implement your own validation logic to validate the input stanza configurations"""\n    # This example accesses the modular input variable\n    # u_splunk_server = definition.parameters.get(\'u_splunk_server\', None)\n    # u_source_app = definition.parameters.get(\'u_source_app\', None)\n    # u_source_collection = definition.parameters.get(\'u_source_collection\', None)\n    # global_account = definition.parameters.get(\'global_account\', None)\n    pass\n\ndef collect_events(helper, ew):\n    """Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_u_splunk_server = helper.get_arg(\'u_splunk_server\')\n    opt_u_source_app = helper.get_arg(\'u_source_app\')\n    opt_u_source_collection = helper.get_arg(\'u_source_collection\')\n    opt_global_account = helper.get_arg(\'global_account\')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_u_splunk_server = helper.get_arg(\'u_splunk_server\', stanza_name)\n    opt_u_source_app = helper.get_arg(\'u_source_app\', stanza_name)\n    opt_u_source_collection = helper.get_arg(\'u_source_collection\', stanza_name)\n    opt_global_account = helper.get_arg(\'global_account\', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username("username")\n    account = helper.get_user_credential_by_id("account id")\n    # get global variable configuration\n    global_userdefined_global_var = helper.get_global_setting("userdefined_global_var")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log("log message")\n    # write to the log using specified log level\n    helper.log_debug("log message")\n    helper.log_info("log message")\n    helper.log_warning("log message")\n    helper.log_error("log message")\n    helper.log_critical("log message")\n    # set the log level for this modular input\n    # (log_level can be "debug", "info", "warning", "error" or "critical", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    """\n\n    \'\'\'\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    \'\'\'\n\n    \'\'\'\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    \'\'\'\n\n    try:\n        import splunklib.client as splunkClient\n        import json\n        import urllib\n    except Exception as err_message:\n        helper.log_error("{}".format(err_message))\n        return 1\n\n  \n    helper.log_info("Modular Input pullkvtoindex started.")\n\n    u_session_key = helper.context_meta.get(\'session_key\')\n    \n    u_splunkserver = helper.get_arg(\'u_splunk_server\')\n    helper.log_info("u_splunkserver={}".format(u_splunkserver))\n\n    u_srcappname = helper.get_arg("u_source_app")\n    helper.log_info("u_destappname={}".format(u_srcappname))\n\n    u_srccollection = helper.get_arg("u_source_collection")\n    helper.log_info("u_destcollection={}".format(u_srccollection))\n    \n    user_account = helper.get_arg(\'global_account\')\n    \n    srcSplunkService = splunkClient.connect(host=u_splunkserver, port=8089, username=user_account.get(\'username\'), password=user_account.get(\'password\'),owner=\'nobody\',app=u_srcappname)\n    \n    srcKVStoreTable = srcSplunkService.kvstore[u_srccollection].data.query()\n    \n    for entry in srcKVStoreTable:\n        dataToIndex = {}\n        orig_key = entry.pop(\'_key\')\n        dataToIndex = {k:entry.get(k) for k,v in entry.items() if not k.startswith(\'_\')}\n        dataToIndex[\'key\'] = orig_key\n        event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=json.dumps(dataToIndex))\n        \n        try:\n            ew.write_event(event)\n        except Exception as e:\n            raise e\n  \n        \n    helper.log_info("Modular Input pullkvtoindex completed.")\n', u'uuid': u'f10a8de31e674e80b38cd717cc11754d'}.get('global_settings', {}).get('customized_settings', [])
            for global_var in customized_settings:
                if global_var.get('type', '') == 'checkbox':
                    checkbox_fields.append(global_var['name'])
            self.global_checkbox_fields = checkbox_fields
        return self.global_checkbox_fields

if __name__ == "__main__":
    exitcode = ModInputkvstore_to_index().run(sys.argv)
    sys.exit(exitcode)
